#!/usr/bin/perl -w

# seeking to convert a Citi credit card PDF statement content to CSV or similar
# I stumbled across the fact that git-bash includes pdftotext, and
# that pdftotext's "simple" mode does a very fine job of extracting what I need
# (in the case perhaps ONLY of this particular CC company's PDF statement)!
# What's left is to slice and dice the "simple" output.  It's only a bit hacky.

# run on output of `pdftotext -simple citiCreditCardStatement.pdf`

use strict;
use warnings;
use English;
use Getopt::Std;
use File::Basename;

my($scriptname, $scriptdirs, $scriptsuffix) = fileparse($0);

sub die_w_usage {
   print STDERR <<"EOT";
$scriptname: diary-grep
usage: $scriptname [-h] [-v] [filename]
  -h   this help
  -v   verbose
EOT
   die "abend\n"
   }

our ($opt_v,$opt_h);
getopts('vh');

sub tocents { my ($dcstr) = @_;  # convert currency to cents to avoid inexact floating point ops
   $dcstr =~ s/[,]//g;
   my ($dol, $cents) = $dcstr =~ /^(\d+)\.(\d{2})$/;
   return (($dol * 100) + $cents);
   }

my (%section_parsers,$minyy);

my $rdt = '\d{2}/\d{2}';
my $rdesc = '\w.*\w';
my $rdamtcapt = '\$([\d,.]+\.\d{2})';
my $rtxn = qr"\s+($rdt)\s+($rdesc)\s+(\-?)$rdamtcapt\b";

my %txns;
sub txn { my ($ctx) = @_;
   if(   m"^$rdt$rtxn"
      ||     m"^$rtxn"
     ) {
      my ($txpostdt,$txdesc,$sign,$txcents) = ($1, $2, $3, tocents($4));
      $txpostdt =~ s!/!-!g;  # ISO8660 sep
      $txpostdt = "$minyy-$txpostdt";
      $txcents = 0 - $txcents if $sign eq '-';
      $txdesc =~ s!\s\s+! # !g;
      printf "$ctx: %s  %7d  %s\n", $txpostdt, $txcents, $txdesc;
      return ($txpostdt, $txcents, $txdesc);
      }
   }

my %charges;
sub chtxns { my ($cardholder) = @_;
   my ($txpostdt, $txcents, $txdesc) = txn( $cardholder );
   $charges{ $cardholder } += $txcents if $txdesc;
   }

my ($cardholder,%cardtotals,$minyy_shown);
sub chs {
 # print "chs: minyy = $minyy\n" unless $minyy_shown; $minyy_shown = 1;
 # print "chs: $_\n" if $opt_v;
   if( !$cardholder ) {
      if( /^($rdesc)\s+Card ending in\s+\d{4}/ ) {
         $cardholder = $1;
         print "cardholder = $cardholder\n" if $opt_v;
         }
      }
   else {
      my ($cardtotal) = m"^New Charges\s+$rdamtcapt";
      if( $cardtotal ) {
       # print "cardholder = $cardholder; cardtotal = $cardtotal\n";
         $cardtotal = tocents( $cardtotal );  # for cross-checking
         print "cardholder = $cardholder; cardtotal = $cardtotal\n" if $opt_v;
         $cardtotals{$cardholder} = $cardtotal;
         my $ch_capt = $cardholder;  # required!
         $section_parsers{ $cardholder } = sub { chtxns( $ch_capt ); };
         updt_section_parsers();
         $cardholder = undef;  # we're done with this $cardholder
         }
      }
   }

sub pymts { txn('Payments&refunds'); }

sub fc {
   for( sort keys %cardtotals ) {
      my ($ct,$chgs) = ($cardtotals{$_},$charges{$_});
      if( $ct != $chgs ) {
         printf "**************************************************************************************\n";
         printf "charges (%7d) != cardtotals (%7d) %-20s DIFFER by %7d !!!\n", $chgs, $ct, $_, $chgs - $ct;
         printf "**************************************************************************************\n";
         }
      else {
         printf "charges (%7d) == cardtotals (%7d) %-20s same\n", $chgs, $ct, $_;
         }
      }

   print "fc done!\n"; exit(0);
   }

%section_parsers = (
   'CARDHOLDER SUMMARY'                => \&chs,
   'Payments, Credits and Adjustments' => \&pymts,
   'Fees Charged'                      => \&fc,
   # 'Interest Charged'   => \&ic,
   # '2021 totals year-to-date' => \&tiytd,
   );

my $section_hdr_re;
sub updt_section_parsers {
   my $reraw = '(?!)';  # never matches  https://stackoverflow.com/a/4589566
      $reraw = '^(' . join( '|', sort keys %section_parsers ) . ')\b' if %section_parsers;
   print "updt_section_parsers = $reraw\n" if $opt_v;
   $section_hdr_re = qr{$reraw};
   }

sub findyr {
   my ($yr) = m"\b\d{2}/\d{2}/(\d{2})\b";
   if( $yr ) {
      $yr += 2000;  # ugh!
      $minyy = $yr if !$minyy || $minyy > $yr;
      }
   }

updt_section_parsers();
my $lineparser = \&findyr;
while( <> ) {
   chomp;
   # print "new line = $_\n";
   if( m"$section_hdr_re" ) {
      my $lphdr = $1;
      die "$lphdr missing!\n" unless exists $section_parsers{ $lphdr };
      $lineparser = delete( $section_parsers{ $lphdr } );
      updt_section_parsers();
      print "lineparser = $lphdr\n" if $opt_v;
      next;
      }
   $lineparser->();
   }
