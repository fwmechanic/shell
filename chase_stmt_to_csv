#!/usr/bin/perl -w

# seeking to convert a Citi credit card PDF statement content to CSV or similar
# I stumbled across the fact that git-bash includes pdftotext, and
# that pdftotext's "simple" mode does a very fine job of extracting what I need
# (in the case perhaps ONLY of this particular CC company's PDF statement)!
# What's left is to slice and dice the "simple" output.  It's only a bit hacky.

# run on output of `pdftotext -simple citiCreditCardStatement.pdf`

use strict;
use warnings;
use English;
use Getopt::Std;

use Cwd ();  # from https://metacpan.org/pod/lib::relative#SYNOPSIS
use File::Basename ();
use File::Spec ();
use lib File::Spec->catdir(File::Basename::dirname(Cwd::abs_path __FILE__), '.');

use MyMods::StmtToCsv;

my($scriptname, $scriptdirs, $scriptsuffix) = File::Basename::fileparse($0);

sub die_w_usage {
   print STDERR <<"EOT";
$scriptname: convert Credit Card PDF statement to structured text (CSV)
usage: $scriptname [-h] [-v] [inputfilename]
  -h   this help
  -v   verbose
EOT
   die "abend\n"
   }

our ($opt_v,$opt_h);
getopts('vh');

my (%section_parsers,$minyy,$maxyy,$acctnum,$purchtotal);

my $rdt = '\d{2}/\d{2}';
my $rdesc = '\w.*\w';
my $rdamtcapt = '([\d,.]*\.\d{2})';
my $rtxn = qr"\s+($rdt)\s+($rdesc)\s+(\-?)$rdamtcapt\b";

my %txns;
sub txn { my ($ctx) = @_;
   if( m"^$rtxn" ) {
      my ($txpostdt,$txdesc,$sign,$txcents) = ($1, $2, $3, MyMods::StmtToCsv::tocents($4));
      $txpostdt =~ s!/!-!g;  # ISO8660 sep
      $txpostdt = (($maxyy && $txpostdt =~ m"01") ? $maxyy : $minyy) . "-$txpostdt";
      $txcents = 0 - $txcents if $sign eq '-';
      $txdesc =~ s!\s\s+! # !g;
      MyMods::StmtToCsv::showtxn( $ctx,$txpostdt, $txcents, $txdesc );
      return ($txpostdt, $txcents, $txdesc);
      }
   }

sub add_txn { my ($cardholder,$sref_accum) = @_;
   my ($txpostdt, $txcents, $txdesc) = txn( $cardholder );
   $$sref_accum += $txcents if $txdesc;
   return 0;
   }

my ($charges,$pymts) = (0,0);
sub lp_pymts   { add_txn('credit'  , \$pymts   ); return 0; }
sub lp_charges { add_txn('purchase', \$charges ); return 0; }

sub lp_done {
   return 1;
   }

%section_parsers = (
   'PAYMENTS'      => \&lp_pymts,
   'PURCHASE'      => \&lp_charges,
   'PURCHASES AND REDEMPTIONS' => \&lp_done,
   'FEES' => \&lp_done,
   'RETURNS' => \&lp_done,
   # 'Fees Charged'  => \&lp_done,
   # 'Interest Charged'   => \&ic,
   # '2021 totals year-to-date' => \&tiytd,
   );

my $section_hdr_re;
sub updt_section_parsers {
   my $reraw = '(?!)';  # never matches  https://stackoverflow.com/a/4589566
      $reraw = '^\s*(' . join( '|', sort keys %section_parsers ) . ')\b' if %section_parsers;
   print "updt_section_parsers = $reraw\n" if $opt_v;
   $section_hdr_re = qr{$reraw};
   }

sub lp_misc_hdr {
   # print "lp_misc_hdr $_\n";
   s/(\w)`(\w)/$1$2/;  # VERY strange translation issue
   my ($anum) = m"^\s*Account Number:\s+\d{4} \d{4} \d{4} (\d{4})\b";
   if( $anum ) {  print "lp_misc_hdr+ anum $anum\n";
      $acctnum = $anum;
      return 0;
      }
   my ($ptot) = m"^\s*Purchases\s+\+\$([\d,]+\.\d{2})";
   if( $ptot ) {  print "lp_misc_hdr+ ptot $ptot\n";
      $purchtotal = MyMods::StmtToCsv::tocents($ptot);
      return 0;
      }
   my ($miny,$maxy) = m"^\s*Opening/Closing Date\s+\d{2}/\d{2}/(\d{2})\s+\-\s+\d{2}/\d{2}/(\d{2})";
   if( $maxy ) {  print "lp_misc_hdr+ miny $miny\n";
      $minyy = $miny + 2000;
      $maxyy = $maxy + 2000 if $miny ne $maxy;
      return 0;
      }
   # print "lp_misc_hdr $_\n";
   return 0;
   }

sub atstart { my ($ifnm) = @_;
   # does not produce desired results:
   # my($ifnmname, $ifnmdirs, $ifnmsuffix) = fileparse($ifnm);
   # print "$ifnm, $ifnmname, $ifnmdirs, $ifnmsuffix\n";
   my ($ifnx) = $ifnm =~ m"(.+\.)[^.]+$";
   my $addltxnfnm = $ifnx . 'addltxns';
   if( -e $addltxnfnm ) {
      print "$addltxnfnm\n\n";
      open my $ifh, '<', $addltxnfnm or die "abend cannot open $addltxnfnm for reading: $!\n";
      while (my $line = <$ifh>) {
         chomp $line;
         if( $line =~ m"\S" ) {
            my ($holder,$dt,$txcents,$desc) = $line =~ m"^($rdesc):\s+(\d{4}\-\d{2}\-\d{2})\s+(\d+)\s+($rdesc)";
            die "bad format in $addltxnfnm: $_\n" unless $desc;
            MyMods::StmtToCsv::showtxn( $holder,$dt,$txcents,$desc );
            $charges += $txcents;
            }
         }
      print "\n";
      }
   print "$ifnm\n\n";
   return $ifnm;
   }

updt_section_parsers();
my $lineparser = \&lp_misc_hdr;
my $fnm1;
while( <> ) {
   $fnm1 = atstart( $ARGV ) unless $fnm1;
   $ARGV eq $fnm1 or die "this program can only process one p2t file\n";
   chomp;
   # print "new line = $_\n";
   if( m"$section_hdr_re" ) {
      my $lphdr = $1;
      die "$lphdr missing!\n" unless exists $section_parsers{ $lphdr };
      print "lineparser = $lphdr\n" if $opt_v;
      $lineparser = delete( $section_parsers{ $lphdr } );
      updt_section_parsers();
      next;
      }
   last if $lineparser->();
   }

print "\ncross-checking\n\n";

if( $charges != $purchtotal ) {
   printf "**************************************************************************************\n";
   printf "charges (%s) != cardtotals (%s) DIFFER by %s !!!\n", MyMods::StmtToCsv::cents_to_dc($charges), MyMods::StmtToCsv::cents_to_dc($purchtotal), MyMods::StmtToCsv::cents_to_dc($charges - $purchtotal);
   printf "**************************************************************************************\n";
   exit(1);
   }
else {
   printf "charges (%s) == cardtotals (%s) same\n", MyMods::StmtToCsv::cents_to_dc($charges), MyMods::StmtToCsv::cents_to_dc($purchtotal);
   }
