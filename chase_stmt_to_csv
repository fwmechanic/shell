#!/usr/bin/perl

# seeking to convert a credit card PDF statement content to CSV or similar
# I stumbled across the fact that git-bash includes pdftotext, and
# that pdftotext's "simple" mode does a very fine job of extracting what I need
# (in the case perhaps ONLY of this particular CC company's PDF statement)!
# What's left is to slice and dice the "simple" output.  It's only a bit hacky.

# run on output of `pdftotext -simple CreditCardStatement.pdf`

use strict;
use warnings;
use English;
use Getopt::Std;

use FindBin;
use lib $FindBin::Bin;
use MyMods::StmtToCsv;
use CCStmtP2tToCsv;

my($scriptname, $scriptdirs, $scriptsuffix) = File::Basename::fileparse($0);
sub die_w_usage {
   print STDERR <<"EOT";
$scriptname: convert Credit Card PDF statement to structured text (CSV)
usage: $scriptname [-h] [-v] [inputfilename]
  -h   this help
  -v   verbose
EOT
   die "abend\n"
   }
my %opts;
getopts('vh', \%opts);
die_w_usage() if $opts{h};
@ARGV == 1 or die "this program can only process one p2t file\n";

my ($yrMin,$yrMax);

my $rdt = '\d{2}/\d{2}';
my $rdesc = '\w.*\w';
my $rdamtcapt = '([\d,]*\.\d{2})';
my $rtxn = qr"\s+($rdt)\s+($rdesc)\s+(\-?)$rdamtcapt\b";

sub lp_ignore {;}
sub add_txn { my ($self,$ctx) = @_;
   defined($yrMin) or die "yrMin not defined prior to txn processing\n";
   if( m"^$rtxn" ) {
      my ($txpostdt,$txdesc,$sign,$txcents) = ($1, $2, $3, MyMods::StmtToCsv::tocents($4));
      $txpostdt =~ s!/!-!g;  # ISO8660 sep
      $txpostdt = (($yrMax && $txpostdt =~ m"^01") ? $yrMax : $yrMin) . "-$txpostdt";  # prepend year
      $txcents = 0 - $txcents if $sign eq '-';
      $txdesc =~ s!\s\s+! # !g;
      MyMods::StmtToCsv::showtxn( $ctx,$txpostdt, $txcents, $txdesc );
      $self->add_txn( $ctx, $txpostdt, $txcents, $txdesc );
      }
   }

my ($closeDate,$acctnum);
sub lp_AcctSummary { my $self = shift;  # print "lp_AcctSummary $_\n";
   s/(\w)`(\w)/$1$2/; # VERY strange translation issue
   if( m"^\s*Payment,\s+Credits\s+(?:\-)?\$([\d,]+\.\d{2})" ) { print  "pymttot raw $1\n";
      $self->set_total( 'credit', - MyMods::StmtToCsv::tocents($1) );
      }
   elsif( m"^\s*Purchases\s+(?:\+)?\$([\d,]+\.\d{2})" ) {  print  "purchtot raw $1\n";
      $self->set_total( 'purchase', MyMods::StmtToCsv::tocents($1) );
      }
 # elsif( m"^\s*Account Number:\s+\d{4} \d{4} \d{4} (\d{4})\b" ) {  print "acctnum $1\n";
 #    $acctnum = $1;  # now obtained from ./AccountId.pl, but may be cross-checked in the future...
 #    }
   elsif( m"^\s*Opening/Closing Date\s+\d{2}/\d{2}/(\d{2})\s+\-\s+(\d{2})/(\d{2})/(\d{2})" ) { print "yrMin/yrMax raw $1/$4\n";
      $yrMin = $1 + 2000;                 print "yrMin $yrMin\n";
      $yrMax = $4 + 2000 if $1 ne $4;     print "yrMax $yrMax\n" if $yrMax;
      $closeDate = $4 + 2000 . "-$2-$3";  print "closeDate $closeDate\n";
      $self->set_stmtCloseDate( $closeDate );
      }
   }

my $init_key = '(start_of_file)';
CCStmtP2tToCsv::process_stmt_p2t( shift,
   {
   $init_key                          => \&lp_ignore,
   'ACCOUNT\s+SUMMARY'                => \&lp_AcctSummary,
   'PAYMENTS\s+AND\s+OTHER\s+CREDITS' => sub {my $self = shift; add_txn( $self, 'credit'   ); },
   'PURCHASE'                         => sub {my $self = shift; add_txn( $self, 'purchase' ); },
   'PURCHASES\s+AND\s+REDEMPTIONS'    => \&lp_ignore,
   'INTEREST\s+CHARGES'               => \&lp_ignore,
   'CASH\s+ADVANCES'                  => \&lp_ignore,
   'BALANCE\s+TRANSFERS'              => \&lp_ignore,
   'FEES\s+CHARGED'                   => \&lp_ignore,
   'RETURNS\s+AND\s+OTHER\s+CREDITS'  => \&lp_ignore,
   }, $init_key, [ qw( credit purchase ) ], \%opts
   );
