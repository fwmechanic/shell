#!/usr/bin/perl -w

# seeking to convert a credit card PDF statement content to CSV or similar
# I stumbled across the fact that git-bash includes pdftotext, and
# that pdftotext's "simple" mode does a very fine job of extracting what I need
# (in the case perhaps ONLY of this particular CC company's PDF statement)!
# What's left is to slice and dice the "simple" output.  It's only a bit hacky.

# run on output of `pdftotext -simple CreditCardStatement.pdf`

use strict;
use warnings;
use English;
use Getopt::Std;

use FindBin;
use lib $FindBin::Bin;
use MyMods::StmtToCsv;

my($scriptname, $scriptdirs, $scriptsuffix) = File::Basename::fileparse($0);

sub die_w_usage {
   print STDERR <<"EOT";
$scriptname: convert Credit Card PDF statement to structured text (CSV)
usage: $scriptname [-h] [-v] [inputfilename]
  -h   this help
  -v   verbose
EOT
   die "abend\n"
   }

our ($opt_v,$opt_h);
getopts('vh');

my ($yrMin,$yrMax,$acctnum,$pymttotal,$purchtotal);

my $rdt = '\d{2}/\d{2}';
my $rdesc = '\w.*\w';
my $rdamtcapt = '([\d,]*\.\d{2})';
my $rtxn = qr"\s+($rdt)\s+($rdesc)\s+(\-?)$rdamtcapt\b";

my %txns;
sub txn { my ($ctx) = @_;
   if( m"^$rtxn" ) {
      my ($txpostdt,$txdesc,$sign,$txcents) = ($1, $2, $3, MyMods::StmtToCsv::tocents($4));
      $txpostdt =~ s!/!-!g;  # ISO8660 sep
      $txpostdt = (($yrMax && $txpostdt =~ m"^01") ? $yrMax : $yrMin) . "-$txpostdt";  # prepend year
      $txcents = 0 - $txcents if $sign eq '-';
      $txdesc =~ s!\s\s+! # !g;
      MyMods::StmtToCsv::showtxn( $ctx,$txpostdt, $txcents, $txdesc );
      return ($txpostdt, $txcents, $txdesc);
      }
   }

sub add_txn { my ($cardholder,$sref_accum) = @_;
   my ($txpostdt, $txcents, $txdesc) = txn( $cardholder );
   $$sref_accum += $txcents if $txdesc;
   return 0;
   }

my ($charges,$pymts) = (0,0);
sub lp_pymts   { add_txn('credit'  , \$pymts   ); return 0; }
sub lp_charges { add_txn('purchase', \$charges ); return 0; }

sub lp_done {
   return 1;
   }

my %section_parsers = (
   'ACCOUNT\s+SUMMARY'                => \&lp_AcctSummary,
   'PAYMENTS\s+AND\s+OTHER\s+CREDITS' => \&lp_pymts,
   'PURCHASE'                         => \&lp_charges,
   'PURCHASES\s+AND\s+REDEMPTIONS'    => \&lp_done,
   'FEES'                             => \&lp_done,
   'RETURNS'                          => \&lp_done,
   # 'Fees Charged'  => \&lp_done,
   # 'Interest Charged'   => \&ic,
   # '2021 totals year-to-date' => \&tiytd,
   );

my $section_hdr_re;
sub updt_section_parsers {
   my $reraw = '(?!)';  # never matches  https://stackoverflow.com/a/4589566
      $reraw = '^\s*(' . join( '|', sort keys %section_parsers ) . ')\b' if %section_parsers;
   print "updt_section_parsers = $reraw\n" if $opt_v;
   $section_hdr_re = qr{$reraw};
   }

sub lp_AcctSummary {  # print "lp_AcctSummary $_\n";
   s/(\w)`(\w)/$1$2/;  # VERY strange translation issue
   if( m"^\s*Account Number:\s+\d{4} \d{4} \d{4} (\d{4})\b" ) {  print "acctnum $1\n";
      $acctnum = $1;
      }
   elsif( m"^\s*Payment,\s+Credits\s+(?:\-)?\$([\d,]+\.\d{2})" ) { print  "pymttot raw $1\n";
      $pymttotal = - MyMods::StmtToCsv::tocents($1);               printf "pymttot %s\n", MyMods::StmtToCsv::cents_to_dc($pymttotal);
      }
   elsif( m"^\s*Purchases\s+(?:\+)?\$([\d,]+\.\d{2})" ) {  print  "purchtot raw $1\n";
      $purchtotal = MyMods::StmtToCsv::tocents($1);        printf "purchtot %s\n", MyMods::StmtToCsv::cents_to_dc($purchtotal);
      }
   elsif( m"^\s*Opening/Closing Date\s+\d{2}/\d{2}/(\d{2})\s+\-\s+\d{2}/\d{2}/(\d{2})" ) { print "yrMin/yrMax raw $1/$2\n";
      $yrMin = $1 + 2000;                 print "yrMin $yrMin\n";
      $yrMax = $2 + 2000 if $1 ne $2;     print "yrMax $yrMax\n" if $yrMax;
      }
   # print "lp_AcctSummary $_\n";
   return 0;
   }

sub atstart { my ($ifnm) = @_;
   # does not produce desired results:
   # my($ifnmname, $ifnmdirs, $ifnmsuffix) = fileparse($ifnm);
   # print "$ifnm, $ifnmname, $ifnmdirs, $ifnmsuffix\n";
   my ($ifnx) = $ifnm =~ m"(.+\.)[^.]+$";
   my $addltxnfnm = $ifnx . 'addltxns';
   if( -e $addltxnfnm ) {
      print "$addltxnfnm\n\n";
      open my $ifh, '<', $addltxnfnm or die "abend cannot open $addltxnfnm for reading: $!\n";
      while (my $line = <$ifh>) {
         chomp $line;
         if( $line =~ m"\S" ) {
            my ($holder,$dt,$txcents,$desc) = $line =~ m"^($rdesc):\s+(\d{4}\-\d{2}\-\d{2})\s+(\d+)\s+($rdesc)";
            die "bad format in $addltxnfnm: $_\n" unless $desc;
            MyMods::StmtToCsv::showtxn( $holder,$dt,$txcents,$desc );
            $charges += $txcents;
            }
         }
      print "\n";
      }
   print "$ifnm\n\n";
   return $ifnm;
   }

updt_section_parsers();
my $lineparser;
my $fnm1;
while( <> ) {
   $fnm1 = atstart( $ARGV ) unless $fnm1;
   $ARGV eq $fnm1 or die "this program can only process one p2t file\n";
   chomp;
   # print "new line = $_\n";
   if( m"$section_hdr_re" ) {
      my $lphdr = $1 =~ s!\s+!\\s+!gr;
      die "$lphdr missing!\n" unless exists $section_parsers{ $lphdr };
      print "lineparser = $lphdr\n" if $opt_v;
      $lineparser = delete( $section_parsers{ $lphdr } );
      updt_section_parsers();
      next;
      }
   last if $lineparser and $lineparser->();
   }

print "\ncross-checking\n\n";

defined( $yrMin      ) or die;
defined( $acctnum    ) or die;
defined( $pymttotal  ) or die;
defined( $purchtotal ) or die;

MyMods::StmtToCsv::cross_chk_totals( $purchtotal, $charges, "charges"  );
MyMods::StmtToCsv::cross_chk_totals( $pymttotal , $pymts  , "payments" );
