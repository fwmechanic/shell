#!/usr/bin/perl

use strict;
use warnings;

sub gen_re_match_all_anyorder {
   # https://www.perlmonks.org/?node_id=308753 (thread: https://www.perlmonks.org/?node_id=308744)
   # to make a specialized version of \b that views "-" and "/" as "word characters" (sort of), you might use something like this:
   # my $w = '\w/-';
   my $w = shift or die "gen_re_match_all_anyorder: no args?";
   my $b = "(?:(*negative_lookbehind:[$w])(*positive_lookahead:[$w])|(*positive_lookbehind:[$w])(*negative_lookahead:[$w]))";
   # my @words = ($rec =~ /${b}[$w]+${b}/g);

   # The following implements a brute-force solution to the performance problem
   # caused by use of \b (or $b, the specialized version of \b) to implement
   # whole-word search terms:
   #
   # The returned search regex consists of a sequence of look-ahead-assertions
   # (LAA), each matching one user search term.  Previously, a word search term
   # would be wrapped in $b and inserted in the LAA sequence, however the
   # presence of \b/$b (caused by the presence of ANY word search term) caused a
   # major (100% == 2x) performance hit.
   #
   # The current resolution is to always insert a non-word-search LAA for each
   # word-search term sought (into @strs), and after all such non-word-search
   # LAA's, append a word-search LAA for each word-search term (into @words).  The
   # idea being that since the LAA's in the regex are evaluated from left to
   # right (sequentially), the fast (non-word) LAA's, which serve to filter out
   # all candidates which cannot possibly match their word-search LAA's, should
   # be evaluated first.  Only if all word terms match (as strings) will the
   # word-search LAA's (if any be applied) to those very few candidate strings
   # passing string search screening.
   #
   my (@strs,@words);
   for my $rawterm (@_) {  # construct regex matching lines containing, in any order, ALL of @_
      my $term = quotemeta( $rawterm );  #  match term
      push @strs,  "(*positive_lookahead:.*$term)"; # https://stackoverflow.com/a/4389683 https://stackoverflow.com/questions/4389644/regex-to-match-string-containing-two-names-in-any-order
      push @words, "(*positive_lookahead:.*$b$term$b)" if ($term =~ m=[A-Z]=) && ($term !~ m=[a-z]=); # all term alphas are caps (i.e. at least one uppercase-alpha and no lowercase-alphas)?: match word as defined by $b + $w
      }
   @strs = sort { length $b <=> length $a } @strs;  # try to find longest strings first
   my $rv = '^(?i)' . join('', @strs) . join('', @words) . '.*$'; # print "\npat=$rv\n";
   return qr($rv);
   }

my $re = gen_re_match_all_anyorder( '\w_', 'ham', 'TAXES' );
my $re = gen_re_match_all_anyorder( '\w_', 'ham', 'T_X' );

my @text = split "\n", <<END;
ham y t_x
 ham y t_x
 y t_x ham
 t_x y ham
t_x y ham
joe ham y t_x
joe ham y t_x joe
ham at_x

hamy y t_x
 hamy y t_x
 y t_x hamy
 t_x y hamy
t_x y hamy
joe hamy y t_x
joe hamy y t_x joe
hamy at_x

hamy  _t_x
 hamy  _t_x
 _t_x hamy
 t_x_ hamy
_t_x hamy
joe hamy _t_x
joe hamy t_x_ joe
hamy at_x

y t_x hamy

at_x ham
END

for( @text ) {
   next if /^\s*$/;
   my $shouldMatch = m"\by\b" ? 1 : 0;
   my $doesMatch   = m"$re"   ? 1 : 0;
   if( $shouldMatch != $doesMatch ) {
      die "should have matched: $_" if $shouldMatch;
      die "shouldn't have matched: $_" if !$shouldMatch;
      die "internal error";
      }
   }
