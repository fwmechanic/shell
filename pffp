#!/usr/bin/env perl
#
# A toolbox for working with ffmpeg to losslessly ('-c copy') cut video files.
# In this case ffmpeg interacts subtly with start times and file keyframes, so
# the best approach is to set -ss param value to exact time of nearest key frame.
# ffprobe must be used to find the timestamps of keyframes, and here we are able
# to find the closest keyframe according to whatever criteria we set.
#
# basis: https://stackoverflow.com/a/17688356

use strict;
use warnings;
use Getopt::Long;

sub max ($$) { $_[$_[0] < $_[1]] }  # https://www.perlmonks.org/?node_id=406885
sub min ($$) { $_[$_[0] > $_[1]] }

sub extof { my($fnm)=@_;
   my($ext) = $fnm =~ m|(\.[^.]+)$|;
   return $ext;
   }

sub dhms_to_secs { my ($stm) = @_;
   my @st = split /:/, $stm;
   my @mhd = (60,60,24);
   my $rv = 0; my $ix = 0; my $mul = 1;
   for my $fr ( reverse @st ) {
      $rv += $fr * $mul;  #  print "mul=$mul fr=$fr\n";
      $mul *= $mhd[$ix++] || die "time $stm too big!\n";
      }
   return $rv;
   }

sub system_silent {
   my $cli = join( ' ', @_ ) . ' 2>&1';
   print 'system_silent: ', $cli, "\n";
   open my $ifh, '-|', $cli or die ;
   my $logfnm = 'ss.log';
   {
   open my $ofh, '>', $logfnm or die "failed opening $logfnm for writing: $!\n";
   while( <$ifh> ) {
      print $ofh $_;
      }
   }
   unlink $logfnm;
   }

sub vidclip { my ($ifnm, $ofnm, $t0, $t1) = @_;
   my @cli = ( 'ffmpeg', '-hide_banner', '-y', '-ss', $t0, '-i', $ifnm, '-to', $t1, '-c', 'copy', $ofnm );
   system_silent( @cli );
   }

sub copy { my ($ifnm, $ofnm) = @_;
   my @cli = ( 'ffmpeg', '-hide_banner', '-y', '-i', $ifnm, '-c', 'copy', $ofnm );
   system_silent( @cli );
   }

sub rmvpfx { my ($ifnm, $ofnm, $tms) = @_;  # "${FFMPEG:-"ffmpeg"}" -hide_banner -y -ss "$2" -i "$1" -c copy "out.$ext"
   my @cli = ( 'ffmpeg', '-hide_banner', '-y', '-ss', $tms, '-i', $ifnm,              '-c', 'copy', $ofnm );
   system_silent( @cli );
   }

sub rmvsfx { my ($ifnm, $ofnm, $tms) = @_;  # ffmpeg -hide_banner -y -i "$1" -c copy -to "$2" "out.$ext"
   my @cli = ( 'ffmpeg', '-hide_banner', '-y', '-i', $ifnm, '-to', $tms, '-c', 'copy', $ofnm );
   system_silent( @cli );
   }

sub ffp_vidfprint { my ($fnm) = @_;
   print "ffp_vidfprint $fnm\n";
   open my $ifh, '-|', 'ffprobe -v error -hide_banner -show_frames -print_format compact "'.$fnm.'" 2>&1' or die "cannot pipe from ffprobe: $!";
   my $first=1; my $acnt=0; my $vcnt=0; my $ts=0.0; my $seen_key = 0;
   while( <$ifh> ) {
      next unless /^frame\|/;
      #print if $first; $first=0;
      if( my($mtyp,$stidx,$iskey,$pts,$ptstime) = /\|media_type=(.).*\|stream_index=(\d+)\|key_frame=(\d)\|pts=(\d+)\|pts_time=(\d+\.\d+)\|/ ) {
         if( $mtyp eq 'v' ) {
            if( $iskey ) { # dump preceding interval
               printf "%12.6f L %12.6f k$seen_key v$vcnt, a$acnt\n", $ts, $ptstime - $ts;
               $ts = $ptstime;
               $seen_key = 1;
               $acnt=0; $vcnt=0;
               }
            else { ++$vcnt; }
            }
         else { ++$acnt; }
         }
      }
   }

sub vid_keyframe_before_rd_intvl { my ($fnm,$t0,$tms,$t1) = @_;  # https://stackoverflow.com/a/14011638
   print "vid_keyframe_before_rd_intvl $fnm,$t0,$tms,$t1\n";     # https://ffmpeg.org/ffprobe.html read_intervals
   open my $ifh, '-|', 'ffprobe -v error -hide_banner -show_frames -read_intervals '."$t0\%$t1".' -select_streams v:0 -print_format compact "'.$fnm.'" 2>&1' or die "cannot pipe from ffprobe: $!";
   my $best;
   while( <$ifh> ) {
      next unless /^frame\|/ && /\|media_type=video\|/;
      if( my($is_keyframe,$ptstime) = /\|key_frame=(\d)\|pts=\d+\|pts_time=(\d+\.\d+)\|/ ) {
         if( $is_keyframe ) {
            printf "%12.6f\n", $ptstime;
            if( $ptstime > $tms ) {  # choose between last kf before $tms (current $best) and first kf after $tms
               $best = $best && $tms - $best < $ptstime - $tms ? $best : $ptstime;
               last;
               }
            $best = $ptstime;
            }
         }
      }
   print "vid_keyframe_before_rd_intvl = ",$best?$best:"none","\n";
   return $best;
   }

sub rp_before { my($ifnm, $ofnm, $tms) = @_;
   for( my $win=2; $win<60; $win *= 2 ) {
      my $ts = vid_keyframe_before_rd_intvl($ifnm, max( $tms - $win, 0 ), $tms, $tms + $win);
      if( $ts ) {
         rmvpfx($ifnm,$ofnm,$ts);
         return;
         }
      }
   die "best_kf_in_window not found\n";
   }

# argv design:
# --if=input_filename
# --of=output_filename (optional; dflt="out.extof(--if)")
# --tm=time
my ($ifnm,$ofnm,$tm,$tms,$fext);
my %runtbl = (
   cp   => sub { copy($ifnm,$ofnm); },
   rp   => sub { rp_before($ifnm,$ofnm,$tms); },
   rs   => sub { rmvsfx   ($ifnm,$ofnm,$tms); },
   pr   => sub { ffp_vidfprint($ifnm); },
   ofpr => sub { ffp_vidfprint($ofnm); },
 # o2i  => sub { push @ifstk, $ifnm; $ifnm = $ofnm; },
   o2i  => sub { $ifnm = $ofnm; },
 # popi => sub { $ifnm = $ofnm; },
   );

sub run { my($arg) = @_;
   $ifnm or die "--if not set when run=$arg\n";
   $fext = extof( $ifnm ); # includes leading '.'
   $ofnm //= "out";
   $ofnm .= $fext unless $ofnm =~ m|\Q$fext\E$|;
   $tm //= 0;
   $tms = dhms_to_secs($tm);
   print "ifnm=$ifnm, fext=$fext, ofnm=$ofnm, tms = $tms\n";
   my $sub = $runtbl{$arg} or die "unsupported run=$arg\n";
   $sub->( $arg );
   }

GetOptions( 'if=s' => \$ifnm, 'of=s' => \$ofnm, 'tm=s' => \$tm, '<>' => \&run );
